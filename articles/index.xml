<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on A Technology Journal</title><link>https://danvalencia.github.io/articles/</link><description>Recent content in Articles on A Technology Journal</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Aug 2013 10:56:50 -0700</lastBuildDate><atom:link href="https://danvalencia.github.io/articles/index.xml" rel="self" type="application/rss+xml"/><item><title>Hands (Part I)</title><link>https://danvalencia.github.io/articles/hands_part_1/</link><pubDate>Thu, 08 Aug 2013 10:56:50 -0700</pubDate><guid>https://danvalencia.github.io/articles/hands_part_1/</guid><description>I&amp;rsquo;m currently helping my friend Dave Gertler to build his Burning Man art installation which is called Hands. Specifically I&amp;rsquo;ll be focusing on the electronics, which is a fairly big chunk of work. In this post I&amp;rsquo;ll introduce you to the project and show you some of the work we&amp;rsquo;ve been doing to make this a reality.
Intro The installation consists of 2 hands with the palms facing upwards. The hands will be made out of CDX plywood and the piece is designed to be assembled as a huge 3D jigsaw puzzle.</description></item><item><title>Closures and Scoping in Javascript</title><link>https://danvalencia.github.io/articles/closures_and_scoping_in_javascript/</link><pubDate>Sat, 02 Feb 2013 10:53:43 -0700</pubDate><guid>https://danvalencia.github.io/articles/closures_and_scoping_in_javascript/</guid><description>Per Wikipedia, a Closure is:
&amp;hellip; a function or reference to a function together with a referencing environmentâ€”a table storing a reference to each of the non-local variables (also called free variables) of that function.
I want you to pay special attention to the last part of that definition: together with a referencing environment, containing references to each of the non-local variables of that function. This is easier explained with a little code:</description></item><item><title>A Performance Testing Methodology</title><link>https://danvalencia.github.io/articles/a_performance_testing_methodology/</link><pubDate>Mon, 29 Oct 2012 10:50:03 -0700</pubDate><guid>https://danvalencia.github.io/articles/a_performance_testing_methodology/</guid><description>The primary goal of any web site performance testing and capacity planning activity is to know how many users can our system handle under acceptable response times given certain hardware specifications. We can get this information by graphing a concurrency vs response time graph.
A typical graph looks like this:
Note how the curve grows exponentially. Depending on the nature of the website (or web pages) under test you might have different acceptable response times.</description></item><item><title>Notes On Continuous Delivery</title><link>https://danvalencia.github.io/articles/notes_on_continuous_delivery/</link><pubDate>Tue, 23 Oct 2012 10:27:00 -0700</pubDate><guid>https://danvalencia.github.io/articles/notes_on_continuous_delivery/</guid><description>Only Build Your Binaries Once Reduce the risk of introducing difference on each build. Takes time to compile code (specially in large systems) Deploy the Same Way to Every Environment Once you reach Production you are confident that your deployments work. Smoke-Test your Deployments After deploying, immediately make sure that the most basic functionality works as expected. Deploy into a copy of Production Make your environments a similar to production as pipeline.</description></item></channel></rss>